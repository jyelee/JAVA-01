学习笔记

代码作业: Week_02/src/main/java/com/jye/week2/HttpClientUtil.java

## 关于GC的总结:

### GC 的模式
* SerialGC: -XX:+UseSerialGC
* ParallelGC: -XX:+UseParallelGC
* CMSGC: -XX:+UseConcMarkSweepGC
* G1GC: -XX:+UseG1GC


### GC 的实现原理
#### 串行GC 
对年轻代使用 mark-copy（标记-复制） 算法，对老年代使用 mark-sweep- compact（标记-清除-整理）算法。
两者都是单线程的垃圾收集器，不能进行并行处理，所以都会触发全线暂停（STW），停止所 有的应用线程。
因此这种 GC 算法不能充分利用多核 CPU。不管有多少 CPU 内核，JVM 在垃圾收集时都只能使用单个核心。
CPU 利用率高，暂停时间长。简单粗暴，就像老式的电脑，动不动就卡死。
该选项只适合几百 MB 堆内存的 JVM，而且是单核 CPU 时比较有用。

#### 并行GC
并行垃圾收集器适用于多核服务器，主要目标是增加吞吐量。因为对系统资源的有效使用，能达到更高的吞吐量:
在 GC 期间，所有 CPU 内核都在并行清理垃圾，所以总暂停时间更短；
在两次 GC 周期的间隔期，没有 GC 线程在运行，不会消耗任何系统资源。

#### CMS GC
CMS 收集器其对年轻代采用并行 STW 方式的 mark-copy (标记-复制)算法，对老年代主要使用并发 mark-sweep (标记-清除)算法。
CMS GC 的设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此目标：
1. 不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收。
2. 在 mark-and-sweep （标记-清除） 阶段的大部分工作和应用线程一起并发执行。 也就是说，在这些阶段并没有明显的应用线程暂停。但值得注意的是，它仍然和应用线程争抢 CPU 时间。默认情况下，
CMS 使用的并发线程数等于 CPU 核心数的 1/4。
如果服务器是多核 CPU，并且主要调优目标是降低 GC 停顿导致的系统延迟，那么使用 CMS 是个很明智的选择。进行老年代的并发回收时，可能会伴随着多次年轻代的 minor GC。
阶段 1: Initial Mark（初始标记）
阶段 2: Concurrent Mark（并发标记）
阶段 3: Concurrent Preclean（并发预清理）
阶段 4: Final Remark（最终标记）
阶段 5: Concurrent Sweep（并发清除）
阶段 6: Concurrent Reset（并发重置）

#### G1 GC
G1 GC 最主要的设计目标是：将 STW 停顿的时间和分布，变成可预期且可配置的。 事实上，G1 GC 是一款软实时垃圾收集器，可以为其设置某项特定的性能指标。为了达成可预期停顿时间的指标，G1 GC 有一些独特的实现。 首先，堆不再分成年轻代和老年代，而是划分为多个（通常是 2048 个）可以存放对象的小块堆区域(smaller heap regions)。每个小块，可能一会被定义成 Eden 区，一会被指定为Survivor区或者 Old 区。在逻辑上，所有的 Eden 区和 Survivor 区合起来就是年轻代，所有的 Old 区拼在一起那就是老年代
这样划分之后，使得 G1 不必每次都去收集整个堆空间，而是以增量的方式来进行处理: 每次只处理一部分内存块，称为此次 GC 的回收集(collection set)。每次 GC 暂停都会收集所 有年轻代的内存块，但一般只包含部分老年代 的内存块。 G1 的另一项创新是，在并发阶段估算每个小堆块存活对象的总数。构建回收集的原则是： 垃圾最多的小块会被优先收集。这也是 G1 名 称的由来。

1、年轻代模式转移暂停（Evacuation Pause）
G1 GC 会通过前面一段时间的运行情况来不断的调整自己的回收策略和行为，以此来比较稳定地控制暂停时间。在应用程序刚启动时，G1 还没有采集到什么足够的信息，这时候就处于初始的 fully-young 模式。当年轻代空间用满后，应用线程会被暂停，年轻代内存块中的存活对象被拷贝到存活区。如果还没有存活区，则任意选择一部分空闲的内存块作为存活区。 拷贝的过程称为转移（Evacuation)，这和前面介绍的其他年轻代收集器是一样的工作原理。

2、并发标记（Concurrent Marking）
同时我们也可以看到，G1 GC 的很多概念建立在 CMS 的基础上，所以下面的内容需要对 CMS 有一定的理解。 G1 并发标记的过程与 CMS 基本上是一样的。G1 的并发标记通过 Snapshot-At-The-Beginning（起 始快照）的方式，在标记阶段开始时记下所有的存活对象。即使在标记的同时又有一些变成了垃圾。通 过对象的存活信息，可以构建出每个小堆块的存活状态，以便回收集能高效地进行选择。 这些信息在接下来的阶段会用来执行老年代区域的垃圾收集。 有两种情况是可以完全并发执行的： 一、如果在标记阶段确定某个小堆块中没有存活对象，只包含垃圾； 二、在 STW 转移暂停期间，同时包含垃圾和存活对象的老年代小堆块。 当堆内存的总体使用比例达到一定数值，就会触发并发标记。这个默认比例是 45%，但也可以通过 JVM参数 InitiatingHeapOccupancyPercent 来设置。和 CMS 一样，G1 的并发标记也是由多个阶段组 成，其中一些阶段是完全并发的，还有一些阶段则会暂停应用线程。
阶段 1: Initial Mark（初始标记） 此阶段标记所有从 GC 根对象直接可达的对象。
阶段 2: Root Region Scan（Root区扫描） 此阶段标记所有从 "根区域" 可达的存活对象。根区域包括：非空的区域，以及在标记过程中不得不收集的区域。
阶段 3: Concurrent Mark（并发标记） 此阶段和 CMS 的并发标记阶段非常类似：只遍历对象图，并在一个特殊的位图中标记能访问到的对象。
阶段 4: Remark（再次标记） 和 CMS 类似，这是一次 STW 停顿(因为不是并发的阶段)，以完成标记过程。 G1 收集器会短暂地停止应用线 程，停止并发更新信息的写入，处理其中的少量信息，并标记所有在并发标记开始时未被标记的存活对象。
阶段 5: Cleanup（清理） 最后这个清理阶段为即将到来的转移阶段做准备，统计小堆块中所有存活的对象，并将小堆块进行排序，以提升 GC 的效率，维护并发标记的内部状态。 所有不包含存活对象的小堆块在此阶段都被回收了。有一部分任务是并 发的：例如空堆区的回收，还有大部分的存活率计算。此阶段也需要一个短暂的 STW 暂停。

3、转移暂停: 混合模式（Evacuation Pause (mixed)）
并发标记完成之后，G1将执行一次混合收集（mixed collection），就是不只清理年轻代，还将一部 分老年代区域也加入到 回收集 中。混合模式的转移暂停不一定紧跟并发标记阶段。有很多规则和历 史数据会影响混合模式的启动时机。比如，假若在老年代中可以并发地腾出很多的小堆块，就没有必 要启动混合模式。 因此，在并发标记与混合转移暂停之间，很可能会存在多次 young 模式的转移暂停。 具体添加到回收集的老年代小堆块的大小及顺序，也是基于许多规则来判定的。其中包括指定的软实 时性能指标，存活性，以及在并发标记期间收集的 GC 效率等数据，外加一些可配置的 JVM 选项。 混合收集的过程，很大程度上和前面的 fully-young gc 是一样的。

### 测试(机器 4c16g, GCLogAnalysis跑2s)
#### 最大内存512M
| GC模式  | 吞吐量               |  延时   | 
| -------  |:-------------: |  -----:  | 
| Serial |  18897 | 单次yong gc: 20ms左右, 单次old gc: 30ms~60ms | 
| Parallel |  11541 | 单次yong gc: 10ms左右, 单次old gc: 30ms~60ms | 
| CMS |  18214 |  | 
| G1 |  17193 |  | 


#### 最大内存1g
| GC模式  | 吞吐量               |  延时   | 
| -------  |:-------------: |  -----:  | 
| Serial |  33641 | 单次yong gc: 20ms左右, 单次old gc: 30ms~60ms | 
| Parallel |  31634 | 单次yong gc: 10ms左右, 单次old gc: 30ms~60ms | 
| CMS |  36721 |  | 
| G1 |  32165  | | 

#### 最大内存2g
| GC模式  | 吞吐量               |  延时   | 
| -------  |:-------------: |  -----:  | 
| Serial |  33583 | 单次yong gc: 20ms左右, 单次old gc: 30ms~60ms | 
| Parallel |  30279 | 单次yong gc: 10ms左右, 单次old gc: 30ms~60ms | 
| CMS |  30114 |  | 
| G1 |  35800 |  | 

#### 最大内存4g
| GC模式  | 吞吐量               |  延时   | 
| -------  |:-------------: |  -----:  | 
| Serial |  33678 | 单次yong gc: 20ms左右 | 
| Parallel |  42396 | 单次yong gc: 10ms左右 | 
| CMS |  26819 |  | 
| G1 |  36543 |  | 

#### 最大内存8g
| GC模式  | 吞吐量               |  延时   | 
| -------  |:-------------: |  -----:  | 
| Serial | 33616  | 单次yong gc: 70ms-140左右 | 
| Parallel |  41383 | 单次yong gc: 40ms-50左右 | 
| CMS |  21537 | 单次yong gc: 40ms-60左右 | 
| G1 |  37884 |  |

#### 测试结论
1. 延时情况 Serial < Parallel < CMS < g1
